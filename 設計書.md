# TimeDonut - 設計書

## 文書情報

| 項目 | 内容 |
|------|------|
| プロジェクト名 | TimeDonut |
| 文書バージョン | 1.0 |
| 最終更新日 | 2025-10-26 |
| 作成者 | Claude Code |
| 関連文書 | 要件定義書.md, 仕様書.md |

---

## 1. アーキテクチャ設計

### 1.1 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                      Presentation Layer                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ MenuBarView  │  │ PopoverView  │  │  SignInView  │      │
│  │  (SwiftUI)   │  │  (SwiftUI)   │  │  (SwiftUI)   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↓ ↑
┌─────────────────────────────────────────────────────────────┐
│                      Business Logic Layer                    │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              ViewModels (ObservableObject)            │   │
│  │  ┌──────────────┐  ┌──────────────┐                 │   │
│  │  │   AppState   │  │ EventsState  │                 │   │
│  │  └──────────────┘  └──────────────┘                 │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓ ↑
┌─────────────────────────────────────────────────────────────┐
│                       Domain Layer                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │CalendarEvent │  │  AuthState   │  │  UserProfile │      │
│  │   (Model)    │  │   (Model)    │  │   (Model)    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↓ ↑
┌─────────────────────────────────────────────────────────────┐
│                    Infrastructure Layer                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ GoogleAuth   │  │  Calendar    │  │   Keychain   │      │
│  │   Manager    │  │   Manager    │  │   Manager    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↓ ↑
┌─────────────────────────────────────────────────────────────┐
│                      External Services                       │
│              Google Calendar API / Google OAuth              │
└─────────────────────────────────────────────────────────────┘
```

**アーキテクチャパターン**: MVVM (Model-View-ViewModel)

**レイヤー責務:**

| レイヤー | 責務 |
|---------|------|
| Presentation | UI表示、ユーザー操作の受付 |
| Business Logic | アプリ状態管理、ビジネスルール |
| Domain | ドメインモデル定義 |
| Infrastructure | 外部システム連携、永続化 |

### 1.2 依存関係ルール

- 上位レイヤーは下位レイヤーに依存可能
- 下位レイヤーは上位レイヤーに依存禁止
- 各レイヤーは同レイヤー内で依存可能
- Infrastructureレイヤーはprotocolで抽象化

---

## 2. ディレクトリ構成

```
TimeDonut/
├── TimeDonut.xcodeproj
├── TimeDonut/
│   ├── App/
│   │   ├── TimeDonutApp.swift           # @main エントリーポイント
│   │   └── AppDelegate.swift            # NSApplicationDelegate
│   │
│   ├── Models/                           # Domain Layer
│   │   ├── CalendarEvent.swift
│   │   ├── AuthState.swift
│   │   └── UserProfile.swift
│   │
│   ├── ViewModels/                       # Business Logic Layer
│   │   ├── AppStateViewModel.swift
│   │   └── EventsViewModel.swift
│   │
│   ├── Views/                            # Presentation Layer
│   │   ├── MenuBar/
│   │   │   └── MenuBarView.swift
│   │   ├── Popover/
│   │   │   ├── PopoverView.swift
│   │   │   ├── ClockDonutView.swift
│   │   │   └── EventListView.swift
│   │   └── Auth/
│   │       └── SignInView.swift
│   │
│   ├── Managers/                         # Infrastructure Layer
│   │   ├── Auth/
│   │   │   ├── GoogleAuthManager.swift
│   │   │   └── KeychainManager.swift
│   │   ├── Calendar/
│   │   │   ├── CalendarManager.swift
│   │   │   └── CalendarAPIClient.swift
│   │   └── MenuBar/
│   │       └── MenuBarManager.swift
│   │
│   ├── Utils/
│   │   ├── Extensions/
│   │   │   ├── Date+Extensions.swift
│   │   │   └── Color+Extensions.swift
│   │   └── Constants.swift
│   │
│   ├── Resources/
│   │   ├── Assets.xcassets/
│   │   └── Info.plist
│   │
│   └── GoogleService-Info.plist
│
└── TimeDonutTests/
    ├── ModelTests/
    ├── ViewModelTests/
    └── ManagerTests/
```

---

## 3. クラス設計

### 3.1 Domain Layer

#### 3.1.1 CalendarEvent

```swift
struct CalendarEvent: Identifiable, Codable, Equatable {
    // MARK: - Properties
    let id: String
    let summary: String
    let startTime: Date
    let endTime: Date
    let colorId: String?
    let calendarId: String
    let isAllDay: Bool
    let status: EventStatus
    let location: String?
    let description: String?

    // MARK: - Computed Properties
    var duration: TimeInterval {
        endTime.timeIntervalSince(startTime)
    }

    var durationFormatted: String {
        let hours = Int(duration) / 3600
        let minutes = (Int(duration) % 3600) / 60

        if hours > 0 {
            return "\(hours)時間\(minutes > 0 ? "\(minutes)分" : "")"
        } else {
            return "\(minutes)分"
        }
    }

    var isOngoing: Bool {
        let now = Date()
        return now >= startTime && now < endTime
    }

    var isPast: Bool {
        Date() >= endTime
    }

    var timeUntilStart: TimeInterval? {
        guard !isOngoing && !isPast else { return nil }
        return startTime.timeIntervalSinceNow
    }

    var color: Color {
        GoogleCalendarColors.color(for: colorId)
    }

    // MARK: - Methods
    func angleRange(for hour: Int) -> (start: Double, end: Double) {
        let startHour = Calendar.current.component(.hour, from: startTime)
        let startMinute = Calendar.current.component(.minute, from: startTime)
        let endHour = Calendar.current.component(.hour, from: endTime)
        let endMinute = Calendar.current.component(.minute, from: endTime)

        let startAngle = Double(startHour % 12) / 12.0 * 360.0 +
                        Double(startMinute) / 60.0 * 30.0
        let endAngle = Double(endHour % 12) / 12.0 * 360.0 +
                      Double(endMinute) / 60.0 * 30.0

        return (startAngle, endAngle)
    }
}

enum EventStatus: String, Codable {
    case confirmed
    case tentative
    case cancelled
}
```

#### 3.1.2 AuthState

```swift
struct AuthState: Codable {
    var isAuthenticated: Bool
    var userEmail: String?
    var userName: String?
    var userPhotoURL: URL?
    var tokenExpirationDate: Date?

    var isTokenExpired: Bool {
        guard let expirationDate = tokenExpirationDate else { return true }
        return Date() >= expirationDate
    }
}
```

#### 3.1.3 UserProfile

```swift
struct UserProfile: Codable {
    let email: String
    let name: String
    let photoURL: URL?
}
```

### 3.2 ViewModels (Business Logic Layer)

#### 3.2.1 AppStateViewModel

```swift
@MainActor
final class AppStateViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var authState: AuthState
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var showSignIn: Bool = false

    // MARK: - Dependencies
    private let authManager: GoogleAuthManager
    private let keychainManager: KeychainManager

    // MARK: - Initialization
    init(
        authManager: GoogleAuthManager = .shared,
        keychainManager: KeychainManager = .shared
    ) {
        self.authManager = authManager
        self.keychainManager = keychainManager
        self.authState = AuthState(isAuthenticated: false)

        Task {
            await checkAuthState()
        }
    }

    // MARK: - Public Methods
    func checkAuthState() async {
        isLoading = true
        defer { isLoading = false }

        do {
            let isAuthenticated = try await authManager.restorePreviousSignIn()
            if isAuthenticated {
                authState.isAuthenticated = true
                authState.userEmail = authManager.currentUser?.profile?.email
                authState.userName = authManager.currentUser?.profile?.name
            } else {
                showSignIn = true
            }
        } catch {
            errorMessage = error.localizedDescription
            showSignIn = true
        }
    }

    func signIn() async {
        isLoading = true
        defer { isLoading = false }

        do {
            try await authManager.signIn()
            authState.isAuthenticated = true
            authState.userEmail = authManager.currentUser?.profile?.email
            authState.userName = authManager.currentUser?.profile?.name
            showSignIn = false
        } catch {
            errorMessage = "サインインに失敗しました: \(error.localizedDescription)"
        }
    }

    func signOut() {
        authManager.signOut()
        authState = AuthState(isAuthenticated: false)
        showSignIn = true
    }
}
```

#### 3.2.2 EventsViewModel

```swift
@MainActor
final class EventsViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var events: [CalendarEvent] = []
    @Published var nextEvent: CalendarEvent?
    @Published var timeUntilNextEvent: String = "予定なし"
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?

    // MARK: - Dependencies
    private let calendarManager: CalendarManager
    private var updateTimer: Timer?
    private var syncTimer: Timer?

    // MARK: - Initialization
    init(calendarManager: CalendarManager = .shared) {
        self.calendarManager = calendarManager
        startTimers()
    }

    deinit {
        stopTimers()
    }

    // MARK: - Public Methods
    func fetchEvents() async {
        isLoading = true
        defer { isLoading = false }

        do {
            events = try await calendarManager.fetchEvents()
            updateNextEvent()
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func refresh() async {
        await fetchEvents()
    }

    // MARK: - Private Methods
    private func startTimers() {
        // UI更新タイマー（1秒ごと）
        updateTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            Task { @MainActor in
                self?.updateTimeUntilNextEvent()
            }
        }

        // データ同期タイマー（5分ごと）
        syncTimer = Timer.scheduledTimer(withTimeInterval: 300.0, repeats: true) { [weak self] _ in
            Task { @MainActor in
                await self?.fetchEvents()
            }
        }

        // 初回データ取得
        Task {
            await fetchEvents()
        }
    }

    private func stopTimers() {
        updateTimer?.invalidate()
        syncTimer?.invalidate()
    }

    private func updateNextEvent() {
        let now = Date()
        nextEvent = events
            .filter { $0.startTime > now || $0.isOngoing }
            .sorted { $0.startTime < $1.startTime }
            .first

        updateTimeUntilNextEvent()
    }

    private func updateTimeUntilNextEvent() {
        guard let event = nextEvent else {
            timeUntilNextEvent = "予定なし"
            return
        }

        if event.isOngoing {
            timeUntilNextEvent = "開催中"
            return
        }

        guard let timeInterval = event.timeUntilStart else {
            timeUntilNextEvent = "予定なし"
            return
        }

        let hours = Int(timeInterval) / 3600
        let minutes = (Int(timeInterval) % 3600) / 60

        if hours > 0 {
            timeUntilNextEvent = "\(hours)時間\(minutes)分後"
        } else if minutes > 0 {
            timeUntilNextEvent = "\(minutes)分後"
        } else {
            timeUntilNextEvent = "まもなく"
        }
    }
}
```

### 3.3 Managers (Infrastructure Layer)

#### 3.3.1 GoogleAuthManager

```swift
final class GoogleAuthManager: ObservableObject {
    // MARK: - Singleton
    static let shared = GoogleAuthManager()

    // MARK: - Properties
    @Published var currentUser: GIDGoogleUser?
    private let keychainManager = KeychainManager.shared

    // MARK: - Configuration
    private let clientID = "YOUR_CLIENT_ID"
    private let scopes = ["https://www.googleapis.com/auth/calendar.readonly"]

    // MARK: - Initialization
    private init() {
        GIDSignIn.sharedInstance.configuration = GIDConfiguration(clientID: clientID)
    }

    // MARK: - Public Methods
    func restorePreviousSignIn() async throws -> Bool {
        return try await withCheckedThrowingContinuation { continuation in
            GIDSignIn.sharedInstance.restorePreviousSignIn { user, error in
                if let error = error {
                    continuation.resume(throwing: error)
                    return
                }

                if let user = user {
                    self.currentUser = user
                    continuation.resume(returning: true)
                } else {
                    continuation.resume(returning: false)
                }
            }
        }
    }

    func signIn() async throws {
        guard let windowScene = NSApplication.shared.windows.first else {
            throw AuthError.noWindow
        }

        let result = try await GIDSignIn.sharedInstance.signIn(
            withPresenting: windowScene,
            hint: nil,
            additionalScopes: scopes
        )

        currentUser = result.user

        // トークン保存
        if let accessToken = currentUser?.accessToken.tokenString {
            try keychainManager.save(token: accessToken, for: .accessToken)
        }

        if let refreshToken = currentUser?.refreshToken.tokenString {
            try keychainManager.save(token: refreshToken, for: .refreshToken)
        }
    }

    func signOut() {
        GIDSignIn.sharedInstance.signOut()
        currentUser = nil
        keychainManager.deleteAll()
    }

    func refreshAccessTokenIfNeeded() async throws {
        guard let user = currentUser else { return }

        if user.accessToken.expirationDate < Date() {
            try await user.refreshTokensIfNeeded()

            if let accessToken = user.accessToken.tokenString {
                try keychainManager.save(token: accessToken, for: .accessToken)
            }
        }
    }
}

enum AuthError: Error {
    case noWindow
    case notAuthenticated
}
```

#### 3.3.2 CalendarManager

```swift
final class CalendarManager {
    // MARK: - Singleton
    static let shared = CalendarManager()

    // MARK: - Dependencies
    private let authManager = GoogleAuthManager.shared
    private let apiClient = CalendarAPIClient()

    // MARK: - Cache
    private var cachedEvents: [CalendarEvent] = []
    private var lastFetchTime: Date?

    // MARK: - Public Methods
    func fetchEvents() async throws -> [CalendarEvent] {
        // トークンリフレッシュ
        try await authManager.refreshAccessTokenIfNeeded()

        guard let accessToken = authManager.currentUser?.accessToken.tokenString else {
            throw CalendarError.notAuthenticated
        }

        let now = Date()
        let calendar = Calendar.current

        let startOfDay = calendar.startOfDay(for: now)
        let endOfTomorrow = calendar.date(byAdding: .day, value: 2, to: startOfDay)!

        let events = try await apiClient.fetchEvents(
            accessToken: accessToken,
            timeMin: startOfDay,
            timeMax: endOfTomorrow
        )

        // キャッシュ更新
        cachedEvents = events
        lastFetchTime = now

        return events
            .filter { $0.status != .cancelled }
            .sorted { $0.startTime < $1.startTime }
    }

    func getCachedEvents() -> [CalendarEvent] {
        return cachedEvents
    }
}

enum CalendarError: Error {
    case notAuthenticated
    case networkError
    case apiError(String)
}
```

#### 3.3.3 CalendarAPIClient

```swift
final class CalendarAPIClient {
    // MARK: - Properties
    private let baseURL = "https://www.googleapis.com/calendar/v3"
    private let session = URLSession.shared

    // MARK: - Public Methods
    func fetchEvents(
        accessToken: String,
        timeMin: Date,
        timeMax: Date
    ) async throws -> [CalendarEvent] {
        let url = URL(string: "\(baseURL)/calendars/primary/events")!

        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)!
        components.queryItems = [
            URLQueryItem(name: "timeMin", value: ISO8601DateFormatter().string(from: timeMin)),
            URLQueryItem(name: "timeMax", value: ISO8601DateFormatter().string(from: timeMax)),
            URLQueryItem(name: "singleEvents", value: "true"),
            URLQueryItem(name: "orderBy", value: "startTime"),
            URLQueryItem(name: "maxResults", value: "50")
        ]

        var request = URLRequest(url: components.url!)
        request.setValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw CalendarError.networkError
        }

        guard httpResponse.statusCode == 200 else {
            throw CalendarError.apiError("HTTP \(httpResponse.statusCode)")
        }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601

        let calendarResponse = try decoder.decode(CalendarResponse.self, from: data)

        return calendarResponse.items.compactMap { $0.toCalendarEvent() }
    }
}

// MARK: - Response Models
struct CalendarResponse: Codable {
    let items: [CalendarEventResponse]
}

struct CalendarEventResponse: Codable {
    let id: String
    let summary: String?
    let start: EventDateTime
    let end: EventDateTime
    let colorId: String?
    let status: String?
    let location: String?
    let description: String?

    func toCalendarEvent() -> CalendarEvent? {
        guard let summary = summary,
              let startDate = start.dateTime,
              let endDate = end.dateTime else {
            return nil
        }

        return CalendarEvent(
            id: id,
            summary: summary,
            startTime: startDate,
            endTime: endDate,
            colorId: colorId,
            calendarId: "primary",
            isAllDay: start.dateTime == nil,
            status: EventStatus(rawValue: status ?? "confirmed") ?? .confirmed,
            location: location,
            description: description
        )
    }
}

struct EventDateTime: Codable {
    let dateTime: Date?
    let date: String?
}
```

#### 3.3.4 KeychainManager

```swift
final class KeychainManager {
    // MARK: - Singleton
    static let shared = KeychainManager()

    private init() {}

    // MARK: - Token Types
    enum TokenType: String {
        case accessToken = "timedonut.accessToken"
        case refreshToken = "timedonut.refreshToken"
        case userEmail = "timedonut.userEmail"
    }

    // MARK: - Public Methods
    func save(token: String, for type: TokenType) throws {
        let data = token.data(using: .utf8)!

        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: type.rawValue,
            kSecValueData as String: data
        ]

        SecItemDelete(query as CFDictionary)

        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            throw KeychainError.saveFailed(status)
        }
    }

    func retrieve(for type: TokenType) throws -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: type.rawValue,
            kSecReturnData as String: true
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess else {
            if status == errSecItemNotFound {
                return nil
            }
            throw KeychainError.retrieveFailed(status)
        }

        guard let data = result as? Data,
              let token = String(data: data, encoding: .utf8) else {
            return nil
        }

        return token
    }

    func delete(for type: TokenType) {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: type.rawValue
        ]

        SecItemDelete(query as CFDictionary)
    }

    func deleteAll() {
        TokenType.allCases.forEach { delete(for: $0) }
    }
}

extension KeychainManager.TokenType: CaseIterable {}

enum KeychainError: Error {
    case saveFailed(OSStatus)
    case retrieveFailed(OSStatus)
}
```

#### 3.3.5 MenuBarManager

```swift
final class MenuBarManager: NSObject {
    // MARK: - Singleton
    static let shared = MenuBarManager()

    // MARK: - Properties
    private var statusItem: NSStatusItem?
    private var popover: NSPopover?

    // MARK: - Initialization
    private override init() {
        super.init()
        setupStatusItem()
    }

    // MARK: - Setup
    private func setupStatusItem() {
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)

        if let button = statusItem?.button {
            button.title = "⏰ ..."
            button.action = #selector(togglePopover)
            button.target = self
            button.sendAction(on: [.leftMouseUp, .rightMouseUp])
        }
    }

    // MARK: - Public Methods
    func updateTitle(_ title: String) {
        DispatchQueue.main.async {
            self.statusItem?.button?.title = "⏰ \(title)"
        }
    }

    func showPopover(with contentView: some View) {
        guard let button = statusItem?.button else { return }

        if popover == nil {
            popover = NSPopover()
            popover?.contentSize = NSSize(width: 360, height: 600)
            popover?.behavior = .transient
        }

        popover?.contentViewController = NSHostingController(rootView: contentView)
        popover?.show(relativeTo: button.bounds, of: button, preferredEdge: .minY)
    }

    func hidePopover() {
        popover?.performClose(nil)
    }

    // MARK: - Actions
    @objc private func togglePopover() {
        let event = NSApp.currentEvent!

        if event.type == .rightMouseUp {
            showContextMenu()
        } else {
            if popover?.isShown == true {
                hidePopover()
            } else {
                NotificationCenter.default.post(name: .showPopover, object: nil)
            }
        }
    }

    private func showContextMenu() {
        let menu = NSMenu()

        menu.addItem(NSMenuItem(title: "更新", action: #selector(refresh), keyEquivalent: "r"))
        menu.addItem(NSMenuItem.separator())
        menu.addItem(NSMenuItem(title: "サインアウト", action: #selector(signOut), keyEquivalent: ""))
        menu.addItem(NSMenuItem.separator())
        menu.addItem(NSMenuItem(title: "終了", action: #selector(quit), keyEquivalent: "q"))

        statusItem?.menu = menu
        statusItem?.button?.performClick(nil)
        statusItem?.menu = nil
    }

    @objc private func refresh() {
        NotificationCenter.default.post(name: .refreshCalendar, object: nil)
    }

    @objc private func signOut() {
        NotificationCenter.default.post(name: .signOut, object: nil)
    }

    @objc private func quit() {
        NSApplication.shared.terminate(nil)
    }
}

// MARK: - Notifications
extension Notification.Name {
    static let showPopover = Notification.Name("showPopover")
    static let refreshCalendar = Notification.Name("refreshCalendar")
    static let signOut = Notification.Name("signOut")
}
```

---

## 4. シーケンス図

### 4.1 起動フロー

```
User          App          AppState     AuthManager    Calendar
 |             |              |              |             |
 |-- 起動 ---> |              |              |             |
 |             |-- init ----> |              |             |
 |             |              |              |             |
 |             |              |-- restore -->|             |
 |             |              |              |             |
 |             |              |              |--Keychain-->|
 |             |              |              |<--Token-----|
 |             |              |              |             |
 |             |              |              |--Google---->|
 |             |              |              |<--User------|
 |             |              |<--Success----|             |
 |             |              |              |             |
 |             |              |--------fetch events------->|
 |             |              |<-------events--------------|
 |             |              |              |             |
 |             |<--表示開始---|              |             |
 |<--Menu Bar--|              |              |             |
```

### 4.2 サインインフロー

```
User       SignInView  AppState   AuthManager  Google
 |             |          |            |          |
 |--クリック-->|          |            |          |
 |             |--signIn->|            |          |
 |             |          |--signIn--->|          |
 |             |          |            |          |
 |             |          |            |--OAuth-->|
 |             |          |            |          |
 |<-------OAuth画面表示(Browser)--------|          |
 |--認証------------------------------>|          |
 |             |          |            |<--Token--|
 |             |          |            |          |
 |             |          |            |--Save--->Keychain
 |             |          |<--Success--|          |
 |             |          |            |          |
 |<--画面遷移--|          |            |          |
```

### 4.3 カレンダー同期フロー

```
Timer      EventsVM   CalendarMgr  APIClient   Google
 |            |           |            |          |
 |--5分経過-->|           |            |          |
 |            |--fetch--->|            |          |
 |            |           |--refresh-->|          |
 |            |           |            |          |
 |            |           |            |--Token-->|
 |            |           |            |          |
 |            |           |            |--API---->|
 |            |           |            |<--Data---|
 |            |           |            |          |
 |            |           |<--Events---|          |
 |            |           |            |          |
 |            |           |--Cache---->Memory
 |            |<--Events--|            |          |
 |            |           |            |          |
 |            |--update UI             |          |
 |<--MenuBar--|           |            |          |
```

---

## 5. データフロー

### 5.1 状態管理

```
                    AppStateViewModel
                           |
        ┌──────────────────┼──────────────────┐
        ↓                  ↓                  ↓
    AuthState       EventsViewModel    MenuBarManager
        |                  |                  |
        |                  ↓                  |
        |            [CalendarEvent]          |
        |                  |                  |
        |                  ↓                  |
        |             nextEvent               |
        |                  |                  |
        └──────────────────┴──────────────────┘
                           ↓
                      UI Update
```

### 5.2 イベントデータフロー

```
Google Calendar API
        ↓
   APIClient (fetch)
        ↓
  CalendarManager (cache)
        ↓
  EventsViewModel (process)
        ↓
   @Published events
        ↓
  ┌─────┴─────┐
  ↓           ↓
MenuBar   ClockDonut
  View        View
```

---

## 6. UI設計詳細

### 6.1 ClockDonutView 実装設計

```swift
struct ClockDonutView: View {
    let events: [CalendarEvent]
    let currentTime: Date

    private let clockRadius: CGFloat = 120
    private let donutInnerRadius: CGFloat = 140
    private let donutOuterRadius: CGFloat = 160

    var body: some View {
        ZStack {
            // ドーナツグラフ (外周)
            ForEach(events) { event in
                DonutSegment(
                    event: event,
                    innerRadius: donutInnerRadius,
                    outerRadius: donutOuterRadius
                )
            }

            // アナログ時計 (中央)
            ClockFace(
                currentTime: currentTime,
                radius: clockRadius
            )
        }
        .frame(width: 340, height: 340)
    }
}

struct DonutSegment: View {
    let event: CalendarEvent
    let innerRadius: CGFloat
    let outerRadius: CGFloat

    var body: some View {
        let (startAngle, endAngle) = event.angleRange(for: 12)

        DonutArc(
            startAngle: .degrees(startAngle - 90),
            endAngle: .degrees(endAngle - 90),
            innerRadius: innerRadius,
            outerRadius: outerRadius
        )
        .fill(event.color)
        .onTapGesture {
            // 予定詳細表示 (Phase 2)
        }
    }
}

struct DonutArc: Shape {
    let startAngle: Angle
    let endAngle: Angle
    let innerRadius: CGFloat
    let outerRadius: CGFloat

    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)

        // 外周の円弧
        path.addArc(
            center: center,
            radius: outerRadius,
            startAngle: startAngle,
            endAngle: endAngle,
            clockwise: false
        )

        // 内周の円弧 (逆方向)
        path.addArc(
            center: center,
            radius: innerRadius,
            startAngle: endAngle,
            endAngle: startAngle,
            clockwise: true
        )

        path.closeSubpath()
        return path
    }
}

struct ClockFace: View {
    let currentTime: Date
    let radius: CGFloat

    var body: some View {
        ZStack {
            // 文字盤
            Circle()
                .fill(Color(nsColor: .controlBackgroundColor))
                .frame(width: radius * 2, height: radius * 2)

            // 時刻目盛り
            ForEach(1...12, id: \.self) { hour in
                ClockHourMark(hour: hour, radius: radius)
            }

            // 針
            ClockHands(time: currentTime, radius: radius)

            // 中央デジタル表示
            DigitalTime(time: currentTime)
        }
    }
}
```

### 6.2 EventListView 実装設計

```swift
struct EventListView: View {
    let events: [CalendarEvent]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("📅 今日の予定")
                .font(.headline)
                .padding(.horizontal)

            ScrollView {
                LazyVStack(spacing: 8) {
                    ForEach(events) { event in
                        EventRow(event: event)
                    }
                }
                .padding(.horizontal)
            }
        }
    }
}

struct EventRow: View {
    let event: CalendarEvent

    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            // 時刻
            VStack(alignment: .trailing, spacing: 4) {
                Text(event.startTime, format: .dateTime.hour().minute())
                    .font(.system(.body, design: .monospaced))
                    .foregroundColor(event.isPast ? .secondary : .primary)

                if event.isOngoing {
                    Text("開催中")
                        .font(.caption)
                        .foregroundColor(.green)
                }
            }
            .frame(width: 60)

            // カラーインジケータ
            RoundedRectangle(cornerRadius: 2)
                .fill(event.color)
                .frame(width: 4)

            // 予定情報
            VStack(alignment: .leading, spacing: 4) {
                Text(event.summary)
                    .font(.body)
                    .foregroundColor(event.isPast ? .secondary : .primary)

                Text(event.durationFormatted)
                    .font(.caption)
                    .foregroundColor(.secondary)

                if let timeUntil = event.timeUntilStart {
                    Text(formatTimeUntil(timeUntil))
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            }

            Spacer()
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(event.isOngoing ? Color.green.opacity(0.1) : Color.clear)
        )
        .opacity(event.isPast ? 0.6 : 1.0)
    }

    private func formatTimeUntil(_ interval: TimeInterval) -> String {
        let hours = Int(interval) / 3600
        let minutes = (Int(interval) % 3600) / 60

        if hours > 0 {
            return "\(hours)時間\(minutes)分後"
        } else {
            return "\(minutes)分後"
        }
    }
}
```

---

## 7. パフォーマンス最適化設計

### 7.1 メモリ最適化

```swift
// イメージキャッシュの制限
class ImageCache {
    static let shared = ImageCache()
    private var cache = NSCache<NSString, NSImage>()

    init() {
        cache.countLimit = 20
        cache.totalCostLimit = 10 * 1024 * 1024 // 10MB
    }
}

// ビューの遅延ロード
struct PopoverView: View {
    @State private var isLoaded = false

    var body: some View {
        Group {
            if isLoaded {
                PopoverContent()
            } else {
                ProgressView()
                    .onAppear {
                        isLoaded = true
                    }
            }
        }
    }
}
```

### 7.2 API呼び出し最適化

```swift
class CalendarManager {
    // 指数バックオフ
    private func fetchWithRetry(maxRetries: Int = 3) async throws -> [CalendarEvent] {
        var retryCount = 0
        var delay: TimeInterval = 1.0

        while retryCount < maxRetries {
            do {
                return try await apiClient.fetchEvents(...)
            } catch {
                retryCount += 1
                if retryCount < maxRetries {
                    try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                    delay *= 2 // 指数バックオフ
                } else {
                    throw error
                }
            }
        }

        throw CalendarError.maxRetriesExceeded
    }
}
```

### 7.3 UI更新最適化

```swift
// Equatableで不要な再描画を防ぐ
struct ClockDonutView: View, Equatable {
    static func == (lhs: ClockDonutView, rhs: ClockDonutView) -> Bool {
        lhs.events.map(\.id) == rhs.events.map(\.id) &&
        lhs.currentTime.timeIntervalSince1970.rounded() ==
        rhs.currentTime.timeIntervalSince1970.rounded()
    }
}
```

---

## 8. エラーハンドリング設計

### 8.1 エラー階層

```swift
protocol AppError: LocalizedError {
    var title: String { get }
    var message: String { get }
    var recoveryOptions: [RecoveryOption] { get }
}

struct RecoveryOption {
    let title: String
    let action: () async -> Void
}

enum NetworkError: AppError {
    case noConnection
    case timeout
    case serverError(Int)

    var title: String {
        switch self {
        case .noConnection: return "接続エラー"
        case .timeout: return "タイムアウト"
        case .serverError: return "サーバーエラー"
        }
    }

    var message: String {
        switch self {
        case .noConnection:
            return "インターネット接続を確認してください"
        case .timeout:
            return "リクエストがタイムアウトしました"
        case .serverError(let code):
            return "サーバーエラーが発生しました (コード: \(code))"
        }
    }

    var recoveryOptions: [RecoveryOption] {
        [RecoveryOption(title: "再試行", action: { /* retry logic */ })]
    }
}
```

---

## 9. テスト設計

### 9.1 単体テスト

```swift
// CalendarEventTests.swift
class CalendarEventTests: XCTestCase {
    func testDurationCalculation() {
        let event = CalendarEvent(
            id: "1",
            summary: "Test",
            startTime: Date(),
            endTime: Date().addingTimeInterval(3600),
            // ...
        )

        XCTAssertEqual(event.duration, 3600)
    }

    func testIsOngoing() {
        let now = Date()
        let event = CalendarEvent(
            startTime: now.addingTimeInterval(-1800),
            endTime: now.addingTimeInterval(1800),
            // ...
        )

        XCTAssertTrue(event.isOngoing)
    }
}

// EventsViewModelTests.swift
class EventsViewModelTests: XCTestCase {
    var viewModel: EventsViewModel!
    var mockCalendarManager: MockCalendarManager!

    override func setUp() {
        mockCalendarManager = MockCalendarManager()
        viewModel = EventsViewModel(calendarManager: mockCalendarManager)
    }

    func testFetchEvents() async {
        // Given
        let mockEvents = [/* mock events */]
        mockCalendarManager.mockEvents = mockEvents

        // When
        await viewModel.fetchEvents()

        // Then
        XCTAssertEqual(viewModel.events.count, mockEvents.count)
    }
}
```

---

## 10. デプロイメント設計

### 10.1 ビルド設定

```
Debug:
- Optimization Level: None
- Swift Compilation Mode: Incremental
- Enable Testability: YES

Release:
- Optimization Level: Optimize for Speed
- Swift Compilation Mode: Whole Module
- Strip Debug Symbols: YES
- Enable Bitcode: NO (macOS)
```

### 10.2 コード署名

```
Development:
- Code Signing: Development
- Provisioning Profile: Automatic

Distribution:
- Code Signing: Developer ID Application
- Notarization: Required
- Hardened Runtime: Enabled
```

---

## 11. 変更履歴

| バージョン | 日付 | 変更内容 | 担当者 |
|-----------|------|----------|--------|
| 1.0 | 2025-10-26 | 初版作成 | Claude Code |

---

**承認欄**

| 役割 | 氏名 | 承認日 | 署名 |
|------|------|--------|------|
| 技術リード | - | 2025-10-26 | - |
| プロジェクトオーナー | - | 2025-10-26 | - |
