# TimeDonut - è¨­è¨ˆæ›¸

## æ–‡æ›¸æƒ…å ±

| é …ç›® | å†…å®¹ |
|------|------|
| ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå | TimeDonut |
| æ–‡æ›¸ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | 1.0 |
| æœ€çµ‚æ›´æ–°æ—¥ | 2025-10-26 |
| ä½œæˆè€… | Claude Code |
| é–¢é€£æ–‡æ›¸ | è¦ä»¶å®šç¾©æ›¸.md, ä»•æ§˜æ›¸.md |

---

## 1. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### 1.1 å…¨ä½“ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Presentation Layer                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ MenuBarView  â”‚  â”‚ PopoverView  â”‚  â”‚  SignInView  â”‚      â”‚
â”‚  â”‚  (SwiftUI)   â”‚  â”‚  (SwiftUI)   â”‚  â”‚  (SwiftUI)   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“ â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Business Logic Layer                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              ViewModels (ObservableObject)            â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚   â”‚
â”‚  â”‚  â”‚   AppState   â”‚  â”‚ EventsState  â”‚                 â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“ â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Domain Layer                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚CalendarEvent â”‚  â”‚  AuthState   â”‚  â”‚  UserProfile â”‚      â”‚
â”‚  â”‚   (Model)    â”‚  â”‚   (Model)    â”‚  â”‚   (Model)    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“ â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Infrastructure Layer                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ GoogleAuth   â”‚  â”‚  Calendar    â”‚  â”‚   Keychain   â”‚      â”‚
â”‚  â”‚   Manager    â”‚  â”‚   Manager    â”‚  â”‚   Manager    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“ â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      External Services                       â”‚
â”‚              Google Calendar API / Google OAuth              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ‘ã‚¿ãƒ¼ãƒ³**: MVVM (Model-View-ViewModel)

**ãƒ¬ã‚¤ãƒ¤ãƒ¼è²¬å‹™:**

| ãƒ¬ã‚¤ãƒ¤ãƒ¼ | è²¬å‹™ |
|---------|------|
| Presentation | UIè¡¨ç¤ºã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã®å—ä»˜ |
| Business Logic | ã‚¢ãƒ—ãƒªçŠ¶æ…‹ç®¡ç†ã€ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ« |
| Domain | ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«å®šç¾© |
| Infrastructure | å¤–éƒ¨ã‚·ã‚¹ãƒ†ãƒ é€£æºã€æ°¸ç¶šåŒ– |

### 1.2 ä¾å­˜é–¢ä¿‚ãƒ«ãƒ¼ãƒ«

- ä¸Šä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ä¸‹ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ä¾å­˜å¯èƒ½
- ä¸‹ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ä¸Šä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ä¾å­˜ç¦æ­¢
- å„ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯åŒãƒ¬ã‚¤ãƒ¤ãƒ¼å†…ã§ä¾å­˜å¯èƒ½
- Infrastructureãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯protocolã§æŠ½è±¡åŒ–

---

## 2. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆ

```
TimeDonut/
â”œâ”€â”€ TimeDonut.xcodeproj
â”œâ”€â”€ TimeDonut/
â”‚   â”œâ”€â”€ App/
â”‚   â”‚   â”œâ”€â”€ TimeDonutApp.swift           # @main ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”‚   â”‚   â””â”€â”€ AppDelegate.swift            # NSApplicationDelegate
â”‚   â”‚
â”‚   â”œâ”€â”€ Models/                           # Domain Layer
â”‚   â”‚   â”œâ”€â”€ CalendarEvent.swift
â”‚   â”‚   â”œâ”€â”€ AuthState.swift
â”‚   â”‚   â””â”€â”€ UserProfile.swift
â”‚   â”‚
â”‚   â”œâ”€â”€ ViewModels/                       # Business Logic Layer
â”‚   â”‚   â”œâ”€â”€ AppStateViewModel.swift
â”‚   â”‚   â””â”€â”€ EventsViewModel.swift
â”‚   â”‚
â”‚   â”œâ”€â”€ Views/                            # Presentation Layer
â”‚   â”‚   â”œâ”€â”€ MenuBar/
â”‚   â”‚   â”‚   â””â”€â”€ MenuBarView.swift
â”‚   â”‚   â”œâ”€â”€ Popover/
â”‚   â”‚   â”‚   â”œâ”€â”€ PopoverView.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ClockDonutView.swift
â”‚   â”‚   â”‚   â””â”€â”€ EventListView.swift
â”‚   â”‚   â””â”€â”€ Auth/
â”‚   â”‚       â””â”€â”€ SignInView.swift
â”‚   â”‚
â”‚   â”œâ”€â”€ Managers/                         # Infrastructure Layer
â”‚   â”‚   â”œâ”€â”€ Auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ GoogleAuthManager.swift
â”‚   â”‚   â”‚   â””â”€â”€ KeychainManager.swift
â”‚   â”‚   â”œâ”€â”€ Calendar/
â”‚   â”‚   â”‚   â”œâ”€â”€ CalendarManager.swift
â”‚   â”‚   â”‚   â””â”€â”€ CalendarAPIClient.swift
â”‚   â”‚   â””â”€â”€ MenuBar/
â”‚   â”‚       â””â”€â”€ MenuBarManager.swift
â”‚   â”‚
â”‚   â”œâ”€â”€ Utils/
â”‚   â”‚   â”œâ”€â”€ Extensions/
â”‚   â”‚   â”‚   â”œâ”€â”€ Date+Extensions.swift
â”‚   â”‚   â”‚   â””â”€â”€ Color+Extensions.swift
â”‚   â”‚   â””â”€â”€ Constants.swift
â”‚   â”‚
â”‚   â”œâ”€â”€ Resources/
â”‚   â”‚   â”œâ”€â”€ Assets.xcassets/
â”‚   â”‚   â””â”€â”€ Info.plist
â”‚   â”‚
â”‚   â””â”€â”€ GoogleService-Info.plist
â”‚
â””â”€â”€ TimeDonutTests/
    â”œâ”€â”€ ModelTests/
    â”œâ”€â”€ ViewModelTests/
    â””â”€â”€ ManagerTests/
```

---

## 3. ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

### 3.1 Domain Layer

#### 3.1.1 CalendarEvent

```swift
struct CalendarEvent: Identifiable, Codable, Equatable {
    // MARK: - Properties
    let id: String
    let summary: String
    let startTime: Date
    let endTime: Date
    let colorId: String?
    let calendarId: String
    let isAllDay: Bool
    let status: EventStatus
    let location: String?
    let description: String?

    // MARK: - Computed Properties
    var duration: TimeInterval {
        endTime.timeIntervalSince(startTime)
    }

    var durationFormatted: String {
        let hours = Int(duration) / 3600
        let minutes = (Int(duration) % 3600) / 60

        if hours > 0 {
            return "\(hours)æ™‚é–“\(minutes > 0 ? "\(minutes)åˆ†" : "")"
        } else {
            return "\(minutes)åˆ†"
        }
    }

    var isOngoing: Bool {
        let now = Date()
        return now >= startTime && now < endTime
    }

    var isPast: Bool {
        Date() >= endTime
    }

    var timeUntilStart: TimeInterval? {
        guard !isOngoing && !isPast else { return nil }
        return startTime.timeIntervalSinceNow
    }

    var color: Color {
        GoogleCalendarColors.color(for: colorId)
    }

    // MARK: - Methods
    func angleRange(for hour: Int) -> (start: Double, end: Double) {
        let startHour = Calendar.current.component(.hour, from: startTime)
        let startMinute = Calendar.current.component(.minute, from: startTime)
        let endHour = Calendar.current.component(.hour, from: endTime)
        let endMinute = Calendar.current.component(.minute, from: endTime)

        let startAngle = Double(startHour % 12) / 12.0 * 360.0 +
                        Double(startMinute) / 60.0 * 30.0
        let endAngle = Double(endHour % 12) / 12.0 * 360.0 +
                      Double(endMinute) / 60.0 * 30.0

        return (startAngle, endAngle)
    }
}

enum EventStatus: String, Codable {
    case confirmed
    case tentative
    case cancelled
}
```

#### 3.1.2 AuthState

```swift
struct AuthState: Codable {
    var isAuthenticated: Bool
    var userEmail: String?
    var userName: String?
    var userPhotoURL: URL?
    var tokenExpirationDate: Date?

    var isTokenExpired: Bool {
        guard let expirationDate = tokenExpirationDate else { return true }
        return Date() >= expirationDate
    }
}
```

#### 3.1.3 UserProfile

```swift
struct UserProfile: Codable {
    let email: String
    let name: String
    let photoURL: URL?
}
```

### 3.2 ViewModels (Business Logic Layer)

#### 3.2.1 AppStateViewModel

```swift
@MainActor
final class AppStateViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var authState: AuthState
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var showSignIn: Bool = false

    // MARK: - Dependencies
    private let authManager: GoogleAuthManager
    private let keychainManager: KeychainManager

    // MARK: - Initialization
    init(
        authManager: GoogleAuthManager = .shared,
        keychainManager: KeychainManager = .shared
    ) {
        self.authManager = authManager
        self.keychainManager = keychainManager
        self.authState = AuthState(isAuthenticated: false)

        Task {
            await checkAuthState()
        }
    }

    // MARK: - Public Methods
    func checkAuthState() async {
        isLoading = true
        defer { isLoading = false }

        do {
            let isAuthenticated = try await authManager.restorePreviousSignIn()
            if isAuthenticated {
                authState.isAuthenticated = true
                authState.userEmail = authManager.currentUser?.profile?.email
                authState.userName = authManager.currentUser?.profile?.name
            } else {
                showSignIn = true
            }
        } catch {
            errorMessage = error.localizedDescription
            showSignIn = true
        }
    }

    func signIn() async {
        isLoading = true
        defer { isLoading = false }

        do {
            try await authManager.signIn()
            authState.isAuthenticated = true
            authState.userEmail = authManager.currentUser?.profile?.email
            authState.userName = authManager.currentUser?.profile?.name
            showSignIn = false
        } catch {
            errorMessage = "ã‚µã‚¤ãƒ³ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ: \(error.localizedDescription)"
        }
    }

    func signOut() {
        authManager.signOut()
        authState = AuthState(isAuthenticated: false)
        showSignIn = true
    }
}
```

#### 3.2.2 EventsViewModel

```swift
@MainActor
final class EventsViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var events: [CalendarEvent] = []
    @Published var nextEvent: CalendarEvent?
    @Published var timeUntilNextEvent: String = "äºˆå®šãªã—"
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?

    // MARK: - Dependencies
    private let calendarManager: CalendarManager
    private var updateTimer: Timer?
    private var syncTimer: Timer?

    // MARK: - Initialization
    init(calendarManager: CalendarManager = .shared) {
        self.calendarManager = calendarManager
        startTimers()
    }

    deinit {
        stopTimers()
    }

    // MARK: - Public Methods
    func fetchEvents() async {
        isLoading = true
        defer { isLoading = false }

        do {
            events = try await calendarManager.fetchEvents()
            updateNextEvent()
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func refresh() async {
        await fetchEvents()
    }

    // MARK: - Private Methods
    private func startTimers() {
        // UIæ›´æ–°ã‚¿ã‚¤ãƒãƒ¼ï¼ˆ1ç§’ã”ã¨ï¼‰
        updateTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            Task { @MainActor in
                self?.updateTimeUntilNextEvent()
            }
        }

        // ãƒ‡ãƒ¼ã‚¿åŒæœŸã‚¿ã‚¤ãƒãƒ¼ï¼ˆ5åˆ†ã”ã¨ï¼‰
        syncTimer = Timer.scheduledTimer(withTimeInterval: 300.0, repeats: true) { [weak self] _ in
            Task { @MainActor in
                await self?.fetchEvents()
            }
        }

        // åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—
        Task {
            await fetchEvents()
        }
    }

    private func stopTimers() {
        updateTimer?.invalidate()
        syncTimer?.invalidate()
    }

    private func updateNextEvent() {
        let now = Date()
        nextEvent = events
            .filter { $0.startTime > now || $0.isOngoing }
            .sorted { $0.startTime < $1.startTime }
            .first

        updateTimeUntilNextEvent()
    }

    private func updateTimeUntilNextEvent() {
        guard let event = nextEvent else {
            timeUntilNextEvent = "äºˆå®šãªã—"
            return
        }

        if event.isOngoing {
            timeUntilNextEvent = "é–‹å‚¬ä¸­"
            return
        }

        guard let timeInterval = event.timeUntilStart else {
            timeUntilNextEvent = "äºˆå®šãªã—"
            return
        }

        let hours = Int(timeInterval) / 3600
        let minutes = (Int(timeInterval) % 3600) / 60

        if hours > 0 {
            timeUntilNextEvent = "\(hours)æ™‚é–“\(minutes)åˆ†å¾Œ"
        } else if minutes > 0 {
            timeUntilNextEvent = "\(minutes)åˆ†å¾Œ"
        } else {
            timeUntilNextEvent = "ã¾ã‚‚ãªã"
        }
    }
}
```

### 3.3 Managers (Infrastructure Layer)

#### 3.3.1 GoogleAuthManager

```swift
final class GoogleAuthManager: ObservableObject {
    // MARK: - Singleton
    static let shared = GoogleAuthManager()

    // MARK: - Properties
    @Published var currentUser: GIDGoogleUser?
    private let keychainManager = KeychainManager.shared

    // MARK: - Configuration
    private let clientID = "YOUR_CLIENT_ID"
    private let scopes = ["https://www.googleapis.com/auth/calendar.readonly"]

    // MARK: - Initialization
    private init() {
        GIDSignIn.sharedInstance.configuration = GIDConfiguration(clientID: clientID)
    }

    // MARK: - Public Methods
    func restorePreviousSignIn() async throws -> Bool {
        return try await withCheckedThrowingContinuation { continuation in
            GIDSignIn.sharedInstance.restorePreviousSignIn { user, error in
                if let error = error {
                    continuation.resume(throwing: error)
                    return
                }

                if let user = user {
                    self.currentUser = user
                    continuation.resume(returning: true)
                } else {
                    continuation.resume(returning: false)
                }
            }
        }
    }

    func signIn() async throws {
        guard let windowScene = NSApplication.shared.windows.first else {
            throw AuthError.noWindow
        }

        let result = try await GIDSignIn.sharedInstance.signIn(
            withPresenting: windowScene,
            hint: nil,
            additionalScopes: scopes
        )

        currentUser = result.user

        // ãƒˆãƒ¼ã‚¯ãƒ³ä¿å­˜
        if let accessToken = currentUser?.accessToken.tokenString {
            try keychainManager.save(token: accessToken, for: .accessToken)
        }

        if let refreshToken = currentUser?.refreshToken.tokenString {
            try keychainManager.save(token: refreshToken, for: .refreshToken)
        }
    }

    func signOut() {
        GIDSignIn.sharedInstance.signOut()
        currentUser = nil
        keychainManager.deleteAll()
    }

    func refreshAccessTokenIfNeeded() async throws {
        guard let user = currentUser else { return }

        if user.accessToken.expirationDate < Date() {
            try await user.refreshTokensIfNeeded()

            if let accessToken = user.accessToken.tokenString {
                try keychainManager.save(token: accessToken, for: .accessToken)
            }
        }
    }
}

enum AuthError: Error {
    case noWindow
    case notAuthenticated
}
```

#### 3.3.2 CalendarManager

```swift
final class CalendarManager {
    // MARK: - Singleton
    static let shared = CalendarManager()

    // MARK: - Dependencies
    private let authManager = GoogleAuthManager.shared
    private let apiClient = CalendarAPIClient()

    // MARK: - Cache
    private var cachedEvents: [CalendarEvent] = []
    private var lastFetchTime: Date?

    // MARK: - Public Methods
    func fetchEvents() async throws -> [CalendarEvent] {
        // ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
        try await authManager.refreshAccessTokenIfNeeded()

        guard let accessToken = authManager.currentUser?.accessToken.tokenString else {
            throw CalendarError.notAuthenticated
        }

        let now = Date()
        let calendar = Calendar.current

        let startOfDay = calendar.startOfDay(for: now)
        let endOfTomorrow = calendar.date(byAdding: .day, value: 2, to: startOfDay)!

        let events = try await apiClient.fetchEvents(
            accessToken: accessToken,
            timeMin: startOfDay,
            timeMax: endOfTomorrow
        )

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°
        cachedEvents = events
        lastFetchTime = now

        return events
            .filter { $0.status != .cancelled }
            .sorted { $0.startTime < $1.startTime }
    }

    func getCachedEvents() -> [CalendarEvent] {
        return cachedEvents
    }
}

enum CalendarError: Error {
    case notAuthenticated
    case networkError
    case apiError(String)
}
```

#### 3.3.3 CalendarAPIClient

```swift
final class CalendarAPIClient {
    // MARK: - Properties
    private let baseURL = "https://www.googleapis.com/calendar/v3"
    private let session = URLSession.shared

    // MARK: - Public Methods
    func fetchEvents(
        accessToken: String,
        timeMin: Date,
        timeMax: Date
    ) async throws -> [CalendarEvent] {
        let url = URL(string: "\(baseURL)/calendars/primary/events")!

        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)!
        components.queryItems = [
            URLQueryItem(name: "timeMin", value: ISO8601DateFormatter().string(from: timeMin)),
            URLQueryItem(name: "timeMax", value: ISO8601DateFormatter().string(from: timeMax)),
            URLQueryItem(name: "singleEvents", value: "true"),
            URLQueryItem(name: "orderBy", value: "startTime"),
            URLQueryItem(name: "maxResults", value: "50")
        ]

        var request = URLRequest(url: components.url!)
        request.setValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")

        let (data, response) = try await session.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw CalendarError.networkError
        }

        guard httpResponse.statusCode == 200 else {
            throw CalendarError.apiError("HTTP \(httpResponse.statusCode)")
        }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601

        let calendarResponse = try decoder.decode(CalendarResponse.self, from: data)

        return calendarResponse.items.compactMap { $0.toCalendarEvent() }
    }
}

// MARK: - Response Models
struct CalendarResponse: Codable {
    let items: [CalendarEventResponse]
}

struct CalendarEventResponse: Codable {
    let id: String
    let summary: String?
    let start: EventDateTime
    let end: EventDateTime
    let colorId: String?
    let status: String?
    let location: String?
    let description: String?

    func toCalendarEvent() -> CalendarEvent? {
        guard let summary = summary,
              let startDate = start.dateTime,
              let endDate = end.dateTime else {
            return nil
        }

        return CalendarEvent(
            id: id,
            summary: summary,
            startTime: startDate,
            endTime: endDate,
            colorId: colorId,
            calendarId: "primary",
            isAllDay: start.dateTime == nil,
            status: EventStatus(rawValue: status ?? "confirmed") ?? .confirmed,
            location: location,
            description: description
        )
    }
}

struct EventDateTime: Codable {
    let dateTime: Date?
    let date: String?
}
```

#### 3.3.4 KeychainManager

```swift
final class KeychainManager {
    // MARK: - Singleton
    static let shared = KeychainManager()

    private init() {}

    // MARK: - Token Types
    enum TokenType: String {
        case accessToken = "timedonut.accessToken"
        case refreshToken = "timedonut.refreshToken"
        case userEmail = "timedonut.userEmail"
    }

    // MARK: - Public Methods
    func save(token: String, for type: TokenType) throws {
        let data = token.data(using: .utf8)!

        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: type.rawValue,
            kSecValueData as String: data
        ]

        SecItemDelete(query as CFDictionary)

        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            throw KeychainError.saveFailed(status)
        }
    }

    func retrieve(for type: TokenType) throws -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: type.rawValue,
            kSecReturnData as String: true
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess else {
            if status == errSecItemNotFound {
                return nil
            }
            throw KeychainError.retrieveFailed(status)
        }

        guard let data = result as? Data,
              let token = String(data: data, encoding: .utf8) else {
            return nil
        }

        return token
    }

    func delete(for type: TokenType) {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: type.rawValue
        ]

        SecItemDelete(query as CFDictionary)
    }

    func deleteAll() {
        TokenType.allCases.forEach { delete(for: $0) }
    }
}

extension KeychainManager.TokenType: CaseIterable {}

enum KeychainError: Error {
    case saveFailed(OSStatus)
    case retrieveFailed(OSStatus)
}
```

#### 3.3.5 MenuBarManager

```swift
final class MenuBarManager: NSObject {
    // MARK: - Singleton
    static let shared = MenuBarManager()

    // MARK: - Properties
    private var statusItem: NSStatusItem?
    private var popover: NSPopover?

    // MARK: - Initialization
    private override init() {
        super.init()
        setupStatusItem()
    }

    // MARK: - Setup
    private func setupStatusItem() {
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)

        if let button = statusItem?.button {
            button.title = "â° ..."
            button.action = #selector(togglePopover)
            button.target = self
            button.sendAction(on: [.leftMouseUp, .rightMouseUp])
        }
    }

    // MARK: - Public Methods
    func updateTitle(_ title: String) {
        DispatchQueue.main.async {
            self.statusItem?.button?.title = "â° \(title)"
        }
    }

    func showPopover(with contentView: some View) {
        guard let button = statusItem?.button else { return }

        if popover == nil {
            popover = NSPopover()
            popover?.contentSize = NSSize(width: 360, height: 600)
            popover?.behavior = .transient
        }

        popover?.contentViewController = NSHostingController(rootView: contentView)
        popover?.show(relativeTo: button.bounds, of: button, preferredEdge: .minY)
    }

    func hidePopover() {
        popover?.performClose(nil)
    }

    // MARK: - Actions
    @objc private func togglePopover() {
        let event = NSApp.currentEvent!

        if event.type == .rightMouseUp {
            showContextMenu()
        } else {
            if popover?.isShown == true {
                hidePopover()
            } else {
                NotificationCenter.default.post(name: .showPopover, object: nil)
            }
        }
    }

    private func showContextMenu() {
        let menu = NSMenu()

        menu.addItem(NSMenuItem(title: "æ›´æ–°", action: #selector(refresh), keyEquivalent: "r"))
        menu.addItem(NSMenuItem.separator())
        menu.addItem(NSMenuItem(title: "ã‚µã‚¤ãƒ³ã‚¢ã‚¦ãƒˆ", action: #selector(signOut), keyEquivalent: ""))
        menu.addItem(NSMenuItem.separator())
        menu.addItem(NSMenuItem(title: "çµ‚äº†", action: #selector(quit), keyEquivalent: "q"))

        statusItem?.menu = menu
        statusItem?.button?.performClick(nil)
        statusItem?.menu = nil
    }

    @objc private func refresh() {
        NotificationCenter.default.post(name: .refreshCalendar, object: nil)
    }

    @objc private func signOut() {
        NotificationCenter.default.post(name: .signOut, object: nil)
    }

    @objc private func quit() {
        NSApplication.shared.terminate(nil)
    }
}

// MARK: - Notifications
extension Notification.Name {
    static let showPopover = Notification.Name("showPopover")
    static let refreshCalendar = Notification.Name("refreshCalendar")
    static let signOut = Notification.Name("signOut")
}
```

---

## 4. ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³

### 4.1 èµ·å‹•ãƒ•ãƒ­ãƒ¼

```
User          App          AppState     AuthManager    Calendar
 |             |              |              |             |
 |-- èµ·å‹• ---> |              |              |             |
 |             |-- init ----> |              |             |
 |             |              |              |             |
 |             |              |-- restore -->|             |
 |             |              |              |             |
 |             |              |              |--Keychain-->|
 |             |              |              |<--Token-----|
 |             |              |              |             |
 |             |              |              |--Google---->|
 |             |              |              |<--User------|
 |             |              |<--Success----|             |
 |             |              |              |             |
 |             |              |--------fetch events------->|
 |             |              |<-------events--------------|
 |             |              |              |             |
 |             |<--è¡¨ç¤ºé–‹å§‹---|              |             |
 |<--Menu Bar--|              |              |             |
```

### 4.2 ã‚µã‚¤ãƒ³ã‚¤ãƒ³ãƒ•ãƒ­ãƒ¼

```
User       SignInView  AppState   AuthManager  Google
 |             |          |            |          |
 |--ã‚¯ãƒªãƒƒã‚¯-->|          |            |          |
 |             |--signIn->|            |          |
 |             |          |--signIn--->|          |
 |             |          |            |          |
 |             |          |            |--OAuth-->|
 |             |          |            |          |
 |<-------OAuthç”»é¢è¡¨ç¤º(Browser)--------|          |
 |--èªè¨¼------------------------------>|          |
 |             |          |            |<--Token--|
 |             |          |            |          |
 |             |          |            |--Save--->Keychain
 |             |          |<--Success--|          |
 |             |          |            |          |
 |<--ç”»é¢é·ç§»--|          |            |          |
```

### 4.3 ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸãƒ•ãƒ­ãƒ¼

```
Timer      EventsVM   CalendarMgr  APIClient   Google
 |            |           |            |          |
 |--5åˆ†çµŒé-->|           |            |          |
 |            |--fetch--->|            |          |
 |            |           |--refresh-->|          |
 |            |           |            |          |
 |            |           |            |--Token-->|
 |            |           |            |          |
 |            |           |            |--API---->|
 |            |           |            |<--Data---|
 |            |           |            |          |
 |            |           |<--Events---|          |
 |            |           |            |          |
 |            |           |--Cache---->Memory
 |            |<--Events--|            |          |
 |            |           |            |          |
 |            |--update UI             |          |
 |<--MenuBar--|           |            |          |
```

---

## 5. ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

### 5.1 çŠ¶æ…‹ç®¡ç†

```
                    AppStateViewModel
                           |
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â†“                  â†“                  â†“
    AuthState       EventsViewModel    MenuBarManager
        |                  |                  |
        |                  â†“                  |
        |            [CalendarEvent]          |
        |                  |                  |
        |                  â†“                  |
        |             nextEvent               |
        |                  |                  |
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
                      UI Update
```

### 5.2 ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

```
Google Calendar API
        â†“
   APIClient (fetch)
        â†“
  CalendarManager (cache)
        â†“
  EventsViewModel (process)
        â†“
   @Published events
        â†“
  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
  â†“           â†“
MenuBar   ClockDonut
  View        View
```

---

## 6. UIè¨­è¨ˆè©³ç´°

### 6.1 ClockDonutView å®Ÿè£…è¨­è¨ˆ

```swift
struct ClockDonutView: View {
    let events: [CalendarEvent]
    let currentTime: Date

    private let clockRadius: CGFloat = 120
    private let donutInnerRadius: CGFloat = 140
    private let donutOuterRadius: CGFloat = 160

    var body: some View {
        ZStack {
            // ãƒ‰ãƒ¼ãƒŠãƒ„ã‚°ãƒ©ãƒ• (å¤–å‘¨)
            ForEach(events) { event in
                DonutSegment(
                    event: event,
                    innerRadius: donutInnerRadius,
                    outerRadius: donutOuterRadius
                )
            }

            // ã‚¢ãƒŠãƒ­ã‚°æ™‚è¨ˆ (ä¸­å¤®)
            ClockFace(
                currentTime: currentTime,
                radius: clockRadius
            )
        }
        .frame(width: 340, height: 340)
    }
}

struct DonutSegment: View {
    let event: CalendarEvent
    let innerRadius: CGFloat
    let outerRadius: CGFloat

    var body: some View {
        let (startAngle, endAngle) = event.angleRange(for: 12)

        DonutArc(
            startAngle: .degrees(startAngle - 90),
            endAngle: .degrees(endAngle - 90),
            innerRadius: innerRadius,
            outerRadius: outerRadius
        )
        .fill(event.color)
        .onTapGesture {
            // äºˆå®šè©³ç´°è¡¨ç¤º (Phase 2)
        }
    }
}

struct DonutArc: Shape {
    let startAngle: Angle
    let endAngle: Angle
    let innerRadius: CGFloat
    let outerRadius: CGFloat

    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)

        // å¤–å‘¨ã®å††å¼§
        path.addArc(
            center: center,
            radius: outerRadius,
            startAngle: startAngle,
            endAngle: endAngle,
            clockwise: false
        )

        // å†…å‘¨ã®å††å¼§ (é€†æ–¹å‘)
        path.addArc(
            center: center,
            radius: innerRadius,
            startAngle: endAngle,
            endAngle: startAngle,
            clockwise: true
        )

        path.closeSubpath()
        return path
    }
}

struct ClockFace: View {
    let currentTime: Date
    let radius: CGFloat

    var body: some View {
        ZStack {
            // æ–‡å­—ç›¤
            Circle()
                .fill(Color(nsColor: .controlBackgroundColor))
                .frame(width: radius * 2, height: radius * 2)

            // æ™‚åˆ»ç›®ç››ã‚Š
            ForEach(1...12, id: \.self) { hour in
                ClockHourMark(hour: hour, radius: radius)
            }

            // é‡
            ClockHands(time: currentTime, radius: radius)

            // ä¸­å¤®ãƒ‡ã‚¸ã‚¿ãƒ«è¡¨ç¤º
            DigitalTime(time: currentTime)
        }
    }
}
```

### 6.2 EventListView å®Ÿè£…è¨­è¨ˆ

```swift
struct EventListView: View {
    let events: [CalendarEvent]

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("ğŸ“… ä»Šæ—¥ã®äºˆå®š")
                .font(.headline)
                .padding(.horizontal)

            ScrollView {
                LazyVStack(spacing: 8) {
                    ForEach(events) { event in
                        EventRow(event: event)
                    }
                }
                .padding(.horizontal)
            }
        }
    }
}

struct EventRow: View {
    let event: CalendarEvent

    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            // æ™‚åˆ»
            VStack(alignment: .trailing, spacing: 4) {
                Text(event.startTime, format: .dateTime.hour().minute())
                    .font(.system(.body, design: .monospaced))
                    .foregroundColor(event.isPast ? .secondary : .primary)

                if event.isOngoing {
                    Text("é–‹å‚¬ä¸­")
                        .font(.caption)
                        .foregroundColor(.green)
                }
            }
            .frame(width: 60)

            // ã‚«ãƒ©ãƒ¼ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿
            RoundedRectangle(cornerRadius: 2)
                .fill(event.color)
                .frame(width: 4)

            // äºˆå®šæƒ…å ±
            VStack(alignment: .leading, spacing: 4) {
                Text(event.summary)
                    .font(.body)
                    .foregroundColor(event.isPast ? .secondary : .primary)

                Text(event.durationFormatted)
                    .font(.caption)
                    .foregroundColor(.secondary)

                if let timeUntil = event.timeUntilStart {
                    Text(formatTimeUntil(timeUntil))
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            }

            Spacer()
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(event.isOngoing ? Color.green.opacity(0.1) : Color.clear)
        )
        .opacity(event.isPast ? 0.6 : 1.0)
    }

    private func formatTimeUntil(_ interval: TimeInterval) -> String {
        let hours = Int(interval) / 3600
        let minutes = (Int(interval) % 3600) / 60

        if hours > 0 {
            return "\(hours)æ™‚é–“\(minutes)åˆ†å¾Œ"
        } else {
            return "\(minutes)åˆ†å¾Œ"
        }
    }
}
```

---

## 7. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–è¨­è¨ˆ

### 7.1 ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–

```swift
// ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®åˆ¶é™
class ImageCache {
    static let shared = ImageCache()
    private var cache = NSCache<NSString, NSImage>()

    init() {
        cache.countLimit = 20
        cache.totalCostLimit = 10 * 1024 * 1024 // 10MB
    }
}

// ãƒ“ãƒ¥ãƒ¼ã®é…å»¶ãƒ­ãƒ¼ãƒ‰
struct PopoverView: View {
    @State private var isLoaded = false

    var body: some View {
        Group {
            if isLoaded {
                PopoverContent()
            } else {
                ProgressView()
                    .onAppear {
                        isLoaded = true
                    }
            }
        }
    }
}
```

### 7.2 APIå‘¼ã³å‡ºã—æœ€é©åŒ–

```swift
class CalendarManager {
    // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
    private func fetchWithRetry(maxRetries: Int = 3) async throws -> [CalendarEvent] {
        var retryCount = 0
        var delay: TimeInterval = 1.0

        while retryCount < maxRetries {
            do {
                return try await apiClient.fetchEvents(...)
            } catch {
                retryCount += 1
                if retryCount < maxRetries {
                    try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                    delay *= 2 // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
                } else {
                    throw error
                }
            }
        }

        throw CalendarError.maxRetriesExceeded
    }
}
```

### 7.3 UIæ›´æ–°æœ€é©åŒ–

```swift
// Equatableã§ä¸è¦ãªå†æç”»ã‚’é˜²ã
struct ClockDonutView: View, Equatable {
    static func == (lhs: ClockDonutView, rhs: ClockDonutView) -> Bool {
        lhs.events.map(\.id) == rhs.events.map(\.id) &&
        lhs.currentTime.timeIntervalSince1970.rounded() ==
        rhs.currentTime.timeIntervalSince1970.rounded()
    }
}
```

---

## 8. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¨­è¨ˆ

### 8.1 ã‚¨ãƒ©ãƒ¼éšå±¤

```swift
protocol AppError: LocalizedError {
    var title: String { get }
    var message: String { get }
    var recoveryOptions: [RecoveryOption] { get }
}

struct RecoveryOption {
    let title: String
    let action: () async -> Void
}

enum NetworkError: AppError {
    case noConnection
    case timeout
    case serverError(Int)

    var title: String {
        switch self {
        case .noConnection: return "æ¥ç¶šã‚¨ãƒ©ãƒ¼"
        case .timeout: return "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"
        case .serverError: return "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼"
        }
    }

    var message: String {
        switch self {
        case .noConnection:
            return "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„"
        case .timeout:
            return "ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ"
        case .serverError(let code):
            return "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ (ã‚³ãƒ¼ãƒ‰: \(code))"
        }
    }

    var recoveryOptions: [RecoveryOption] {
        [RecoveryOption(title: "å†è©¦è¡Œ", action: { /* retry logic */ })]
    }
}
```

---

## 9. ãƒ†ã‚¹ãƒˆè¨­è¨ˆ

### 9.1 å˜ä½“ãƒ†ã‚¹ãƒˆ

```swift
// CalendarEventTests.swift
class CalendarEventTests: XCTestCase {
    func testDurationCalculation() {
        let event = CalendarEvent(
            id: "1",
            summary: "Test",
            startTime: Date(),
            endTime: Date().addingTimeInterval(3600),
            // ...
        )

        XCTAssertEqual(event.duration, 3600)
    }

    func testIsOngoing() {
        let now = Date()
        let event = CalendarEvent(
            startTime: now.addingTimeInterval(-1800),
            endTime: now.addingTimeInterval(1800),
            // ...
        )

        XCTAssertTrue(event.isOngoing)
    }
}

// EventsViewModelTests.swift
class EventsViewModelTests: XCTestCase {
    var viewModel: EventsViewModel!
    var mockCalendarManager: MockCalendarManager!

    override func setUp() {
        mockCalendarManager = MockCalendarManager()
        viewModel = EventsViewModel(calendarManager: mockCalendarManager)
    }

    func testFetchEvents() async {
        // Given
        let mockEvents = [/* mock events */]
        mockCalendarManager.mockEvents = mockEvents

        // When
        await viewModel.fetchEvents()

        // Then
        XCTAssertEqual(viewModel.events.count, mockEvents.count)
    }
}
```

---

## 10. ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆè¨­è¨ˆ

### 10.1 ãƒ“ãƒ«ãƒ‰è¨­å®š

```
Debug:
- Optimization Level: None
- Swift Compilation Mode: Incremental
- Enable Testability: YES

Release:
- Optimization Level: Optimize for Speed
- Swift Compilation Mode: Whole Module
- Strip Debug Symbols: YES
- Enable Bitcode: NO (macOS)
```

### 10.2 ã‚³ãƒ¼ãƒ‰ç½²å

```
Development:
- Code Signing: Development
- Provisioning Profile: Automatic

Distribution:
- Code Signing: Developer ID Application
- Notarization: Required
- Hardened Runtime: Enabled
```

---

## 11. å¤‰æ›´å±¥æ­´

| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | æ—¥ä»˜ | å¤‰æ›´å†…å®¹ | æ‹…å½“è€… |
|-----------|------|----------|--------|
| 1.0 | 2025-10-26 | åˆç‰ˆä½œæˆ | Claude Code |

---

**æ‰¿èªæ¬„**

| å½¹å‰² | æ°å | æ‰¿èªæ—¥ | ç½²å |
|------|------|--------|------|
| æŠ€è¡“ãƒªãƒ¼ãƒ‰ | - | 2025-10-26 | - |
| ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚ªãƒ¼ãƒŠãƒ¼ | - | 2025-10-26 | - |
